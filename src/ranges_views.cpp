#include "ranges_views.hpp"
#include <algorithm>
#include <cassert>
#include <iterator>
#include <numeric>
#include <print>
#include <ranges>
#include <vector>

namespace stdr = std::ranges;
namespace stdv = std::views;

void demo_ranges_views() {
    int a[]{1, 2, 3, 4, 5};
    auto size = stdr::size(a);
    std::println("size of a: {}", size);
    std::vector<int> con{1, 7, 2, 4, 7, 2, 5};
    assert(stdr::range<decltype(con)> && "std::vector is not a range");
    auto res = stdr::subrange(con.begin(), con.begin() + 2);
    std::print("First two elements of vector 'con': ");
    for (auto e : res) {
        std::print("{} ", e);
    }

    std::println("1 to 10 with odd numbers (take 3):");
    for (const auto e : stdv::iota(1, 10) | stdv::filter([](int num) {
                            return num % 2 == 1;
                        }) | stdv::take(3)) {
        std::print("{} ", e);
    }
    std::println();
    auto chunk_res = con | stdv::chunk(3);
    for (const auto e : chunk_res) {
        std::print("{} ", e);
    }
    std::println();
    std::string str{"This is a string case for view split"};
    auto str_view = str | stdv::transform([](char c) { return c; });
    for (const auto e : str_view) {
        std::print("{} ", e);
    }
    std::println();
    auto str_split = str_view | stdv::split(' ');
    for (const auto e : str_split) {
        std::print("{} ", e);
    }
    std::println();
    auto sum = std::accumulate(con.begin(), con.end(), 0);
    std::println("sum of con: {}", sum);
    auto prod =
        std::accumulate(con.begin(), con.end(), 1, std::multiplies<int>());
    std::println("product of con: {}", prod);
    auto max_val = *stdr::max_element(con);
    std::println("max value in con: {}", max_val);
    auto min_val = *stdr::min_element(con);
    std::println("min value in con: {}", min_val);
    auto sorted_con = stdr::sort(con);
}

/* 考虑以下两种令人烦恼的情形:
 * 1. range-for中你必须迭代所有元素;
 * 2. std::sort()你必须指定xx.begin(), xx.end()
 * Range应运而生,在C++20中他还有很多bug,c++23支持不错,但是不够全面,在C++26中则很nice
 * Range定义: 提供了起始迭代器和结束哨兵的类型,也就说可以实现整体迭代 -> a
 * container is a range
 * View定义: a range that can be moved in O(1), copied (or can not be copied) in
 * O(1), deconstruced in O(1)(note: dont consider the deconstruction of each
 * elements)
 ! [notes: a significant of the view generated by range adaptor is corresponding
 ! caculcation happens lazily] 惰性求值,有计算需求才进行一次计算. one more,
 since range ! and view is concepts, so then there is "range a" or "view b".
 *
 */